---
description: 
globs: 
alwaysApply: true
---
# Arbitrum Vibekit V2 Agent Creation Guide

_A comprehensive guide for creating on-chain AI agents using the Arbitrum Vibekit v2 framework - enabling vibe coding (AI-generated working code) in minutes._

## Core V2 Principles

1. **Skills-First Architecture**: Define what your agent can do through skills that coordinate multiple tools
2. **LLM Orchestration**: Let AI intelligently route and coordinate complex multi-tool workflows
3. **Modern Transport**: Use StreamableHTTP with legacy SSE backwards compatibility
4. **Context Providers**: Share data like token mappings, RPC connections across tools cleanly
5. **Production Ready**: Built-in health checks, metrics, agent cards, and deployment patterns

## V2 Architecture Overview

The v2 framework centers around a three-layer architecture:

### Skills (Public Interface)
Skills define what your agent can do and serve as the public interface:

```typescript
export const lendingSkill = defineSkill({
  id: 'lending-operations',
  name: 'Lending Operations', 
  description: 'Perform lending operations on Aave protocol',
  tags: ['defi', 'lending'],
  examples: ['Supply 100 USDC', 'Borrow 50 ETH'],
  
  inputSchema: z.object({
    instruction: z.string(),
    walletAddress: z.string(),
  }),
  
  tools: [supplyTool, borrowTool, repayTool, withdrawTool],
  // No handler = LLM orchestration (recommended)
});
```

### Tools (Internal Implementation)
Tools implement the actual business logic:

```typescript
export const supplyTool = defineTool({
  name: 'supplyToken',
  description: 'Supply tokens to Aave lending pool',
  inputSchema: z.object({
    token: z.string(),
    amount: z.number(),
    walletAddress: z.string(),
  }),
  implementation: async (args, context) => {
    // Tool implementation here
  },
});
```

### LLM Orchestration
The LLM intelligently routes requests and coordinates tools automatically.

## V2 Development Patterns

### Provider Selection
Unified LLM provider access across multiple providers:

```typescript
const providers = createProviderSelector({
  openRouterApiKey: process.env.OPENROUTER_API_KEY,
  anthropicApiKey: process.env.ANTHROPIC_API_KEY,
  openaiApiKey: process.env.OPENAI_API_KEY,
  xaiApiKey: process.env.XAI_API_KEY,
});

const agent = Agent.create(agentConfig, {
  llm: { model: providers.openrouter('google/gemini-2.5-flash') }
});
```

### Context Providers
Share data across tools cleanly:

```typescript
export const contextProvider: ContextProvider<MyContext> = async (deps) => {
  return {
    tokenMap: await loadTokenMap(),
    rpcProvider: createProvider(process.env.RPC_URL),
    emberClient: deps.mcpClients['ember'],
  };
};
```

### Hook Enhancement
Add cross-cutting concerns without cluttering business logic:

```typescript
export const enhancedTool = withHooks(baseTool, {
  before: [validateInputHook, authHook],
  after: [formatResponseHook, metricsHook],
});
```

## Agent Directory Structure

V2 agents follow this standard structure:

```
agent-name/
├── src/
│   ├── index.ts          # Agent entry point and MCP server setup
│   ├── config.ts         # Agent configuration
│   ├── skills/           # Skill definitions (high-level capabilities)
│   │   ├── lending.ts    # Example: lending skill with multiple tools
│   │   ├── trading.ts    # Example: trading skill
│   │   └── analytics.ts  # Example: analytics skill
│   ├── tools/            # Tool implementations (actions)
│   │   ├── supply.ts     # Example: supply tool
│   │   ├── borrow.ts     # Example: borrow tool
│   │   └── swap.ts       # Example: swap workflow tool
│   ├── hooks/            # Tool enhancement hooks (optional)
│   │   └── index.ts      # Before/after hooks for tools
│   └── context/          # Shared context and types (optional)
│       ├── provider.ts   # Context provider
│       └── types.ts      # Type definitions
├── test/                 # Test files
├── package.json          # Agent dependencies
├── tsconfig.json         # TypeScript configuration
├── Dockerfile           # Container definition
├── Dockerfile.prod      # Production container
└── README.md            # Agent documentation
```

## Skill and Tool Design

### Required Skill Metadata

```typescript
export const mySkill = defineSkill({
  // Core identity
  id: 'unique-skill-id',           // Required: unique identifier
  name: 'Human Readable Name',     // Required: display name
  description: 'What this does',   // Required: clear capability description

  // Discovery (required)
  tags: ['tag1', 'tag2'],         // Required: minimum 1 tag
  examples: ['Example 1'],         // Required: minimum 1 example

  // Interface
  inputSchema: z.object({...}),    // Required: input validation

  // Implementation
  tools: [tool1, tool2],          // Required: minimum 1 tool

  // Optional
  mcpServers: [...],              // External dependencies
  handler: async (input) => {...} // Manual override (rare)
});
```

### Design Philosophy

Skills follow the Agent-to-Agent (A2A) protocol:
- **One Skill = One Capability** - Each skill represents a cohesive capability
- **Opaque Implementation** - Internal workings hidden from callers
- **Clear Interface** - Well-defined inputs and outputs

### When to Use Multiple Tools

Use multiple tools when actions are:
- **Independent** - Users might want just one
- **Composable** - Can be mixed based on needs
- **Distinct** - Require different intent interpretation

```typescript
// Good: Independent lending actions
tools: [supplyTool, borrowTool, repayTool, withdrawTool]
```

### When to Use Workflow Tools

Create workflow tools for multi-step processes that always occur together:

```typescript
// Good: Swap always requires quote → approve → execute
tools: [executeSwapWorkflow]

// Bad: Exposing internal steps as separate tools
tools: [getQuoteTool, approveTokenTool, executeSwapTool]
```

### LLM Orchestration vs Manual Handlers

**Use LLM Orchestration When:**
- Multiple tools need coordination
- Natural language input is important
- Complex workflows with conditional logic
- User intent varies significantly

**Use Manual Handlers When:**
- Simple, deterministic operations
- Performance is critical
- Complete control over logic flow is needed
- Predefined input/output mapping

## Modern Transport and Deployment

### Agent Cards & Service Discovery
Every v2 agent automatically publishes an agent card:

```json
// GET /.well-known/agent.json
{
  "name": "Lending Agent",
  "version": "1.0.0",
  "description": "A DeFi lending agent for Aave protocol",
  "skills": [...],
  "endpoints": {
    "mcp": "/mcp",
    "health": "/health"
  }
}
```

### Modern Transport
- **StreamableHTTP** (default): Latest MCP SDK, better performance
- **Legacy SSE**: Backwards compatibility via `enableLegacySseTransport: true`

### Production Features
- Built-in health endpoints
- Metrics collection
- Structured logging
- Docker containers
- Environment-based configuration

## Getting Started

### 1. Use a Template
Start with an existing v2 template:

```bash
cd typescript/templates
cp -r quickstart-agent my-custom-agent
cd my-custom-agent
```

### 2. Configure Environment
```bash
cp .env.example .env
# Edit .env with your API keys
```

### 3. Customize Skills
Replace template skills with your own:

```typescript
// src/skills/mySkill.ts
export const mySkill = defineSkill({
  id: 'my-capability',
  name: 'My Capability',
  description: 'What my agent does',
  tools: [myTool1, myTool2],
  // Let LLM orchestrate
});
```

### 4. Implement Tools
```typescript
// src/tools/myTool.ts
export const myTool = defineTool({
  name: 'myAction',
  description: 'Specific action my agent performs',
  inputSchema: z.object({
    param: z.string(),
  }),
  implementation: async (args, context) => {
    // Your business logic
    return { success: true };
  },
});
```

### 5. Start Development
```bash
pnpm install
pnpm dev
```

## Best Practices

### Skill Design
1. **Clear boundaries**: One skill = one capability
2. **Natural language friendly**: Support varied user input
3. **Comprehensive examples**: Help LLM understand usage
4. **Proper tagging**: Enable discovery

### Tool Implementation
1. **Single responsibility**: One tool = one action
2. **Clear descriptions**: Help LLM select appropriate tool
3. **Robust validation**: Use Zod schemas
4. **Error handling**: Return structured errors

### Context Management
1. **Shared resources**: Use context providers for common data
2. **Clean separation**: Context vs tool-specific logic
3. **Type safety**: Define clear context interfaces

### Production Readiness
1. **Environment variables**: Externalize all configuration
2. **Health monitoring**: Implement custom health checks
3. **Error handling**: Graceful failure and recovery
4. **Documentation**: Clear README and API docs

## Common Patterns

### Multi-Tool Skills
```typescript
// DeFi operations with multiple independent actions
export const defiSkill = defineSkill({
  id: 'defi-operations',
  tools: [supply, borrow, swap, stake, unstake]
});
```

### Single-Tool Skills
```typescript
// Focused capability that might expand later
export const priceSkill = defineSkill({
  id: 'price-prediction',
  tools: [getPricePrediction] // Easy to add more tools later
});
```

### Workflow Skills
```typescript
// Coordinated multi-step processes
export const portfolioSkill = defineSkill({
  id: 'portfolio-optimization',
  tools: [optimizePortfolioWorkflow] // Handles analysis → rebalancing → execution
});
```

## Testing and Validation

### Unit Testing
```typescript
describe('MySkill', () => {
  it('should handle user requests correctly', async () => {
    const result = await mySkill.handler({
      instruction: 'Test request',
      walletAddress: '0x123...'
    });
    expect(result.success).toBe(true);
  });
});
```

### Integration Testing
```typescript
describe('Agent Integration', () => {
  it('should start and expose MCP endpoints', async () => {
    const agent = Agent.create(agentConfig, runtimeOptions);
    await agent.start(3000);
    
    // Test agent card
    const response = await fetch('http://localhost:3000/.well-known/agent.json');
    expect(response.ok).toBe(true);
  });
});
```

## Resources

- [Template Agents](mdc:https:/github.com/EmberAGI/arbitrum-vibekit/tree/main/typescript/templates) - Production-ready examples
- [V2 Lessons](mdc:https:/github.com/EmberAGI/arbitrum-vibekit/tree/main/typescript/lib/arbitrum-vibekit-core/docs) - Detailed learning materials
- [MCP Tools](mdc:https:/github.com/EmberAGI/arbitrum-vibekit/tree/main/typescript/lib/mcp-tools) - External service integrations
