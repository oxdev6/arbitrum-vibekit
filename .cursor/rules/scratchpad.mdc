---
description: 
globs: 
alwaysApply: true
---
# Scratchpad

## Background and Motivation

The user wants to refactor the existing `typescript/examples/liquidity-agent-no-wallet` AI agent to **remove its current swapping capabilities** and add DeFi liquidity management features (supplying and withdrawing liquidity from pools), similar to a provided example snippet. A key requirement is to use the Model Context Protocol (MCP) for interacting with the Ember backend via the `emberai-mcp-tool-server` for the new liquidity features.

**Update:** The agent *will* now interact directly with the blockchain using Viem and QuickNode to perform **token balance checks** and **allowance checks** before calling MCP tools. It will also **construct necessary ERC20 approval transactions** itself, prepending them to the transaction plan received from the MCP tools. The final result returned to the user will be packaged in a structured `Task` artifact, similar to the swapping agent.

The agent must not handle private keys or sign transactions; instead, it should return the complete transaction plans (including approvals) generated by the MCP tools and the agent itself for the user (or another system) to execute. The refactoring should involve minimal changes *beyond these additions*, preserving the original file structure and overall architecture where possible, focusing on liquidity management augmented with on-chain checks and approval handling.

## Key Challenges and Analysis

1.  **Mapping Features to MCP Tools:** The desired liquidity features need to be mapped to the corresponding MCP tools (`getLiquidityPools`, `supplyLiquidity`, `getUserLiquidityPositions`, `withdrawLiquidity`).
2.  **Parameter Alignment:** Arguments for OpenAI functions need correct transformation for MCP tool parameters (pair symbols to addresses/chain IDs, amounts). `getLiquidityPools` response needs parsing for `supplyLiquidity`. `getUserLiquidityPositions` response needs parsing for `withdrawLiquidity` (getting `tokenId`, `providerId`).
3.  **Handling MCP Responses:** Correctly invoke MCP tools and parse **JSON** responses **using Zod schemas** derived from the `emberai-mcp-tool-server` definitions. Extract transaction plan JSON for `supplyLiquidity` and `withdrawLiquidity`. **Define Zod schemas for `GetLiquidityPoolsResponse` and `GetUserLiquidityPositionsResponse`.**
4.  **On-Chain Interaction (Re-added):**
    *   **QuickNode/Viem Setup:** Reintegrate QuickNode configuration (`QUICKNODE_SUBDOMAIN`, `QUICKNODE_API_KEY`) and Viem `PublicClient` creation logic. Requires adding `viem/chains` dependency.
    *   **Balance Checks:** Implement logic in `handleSupplyLiquidity` to check the user's balance for *both* `token0` and `token1` of the selected pair using the Viem client and `Erc20Abi`.
    *   **Allowance Checks:** Implement logic in `handleSupplyLiquidity` to check the user's ERC20 allowance for *both* `token0` and `token1` towards the spender address (obtained from the *first* transaction in the MCP plan) using Viem client and `Erc20Abi`.
    *   **Approval Transaction Generation:** If allowances are insufficient, generate standard ERC20 `approve` transactions using Viem's `encodeFunctionData` and `Erc20Abi`.
5.  **State Management (Liquidity):** Fetch and store available liquidity pools (`pairs`) and user positions (`positions`) using MCP tools. **Populate `this.pairs` and `this.positions` from the validated Zod schema outputs.** The internal structure of these state variables should facilitate mapping user input (pair handle, position number) to MCP tool parameters (`token0Address`, `token1Address`, `tokenId`, `providerId`) and on-chain check parameters.
6.  **Integrating MCP Client:** Adapt the agent to initialize and use an MCP client connected to `emberai-mcp-tool-server`.
7.  **Removing Swapping Logic:** Identify and remove all code related to token swapping, including OpenAI function definitions, tool handlers, and any specific state or logic related to swaps.
8.  **Task Artifact Structure (Re-added):** Define a structured artifact format (e.g., similar to `TransactionArtifact` in the swapping agent) for the `supplyLiquidity` and `withdrawLiquidity` handlers to return results, potentially including a `txPreview` section alongside the `txPlan`. Define corresponding Zod schema.
9.  **Ambiguity Handling (Added):** While less critical than swapping due to unique pool handles, ensure the agent can request clarification if user input is ambiguous regarding pool selection or parameters, potentially requiring updates to the system prompt or handler logic to return `input-required` states.
10. **Dependency Management (Re-added):** Ensure `package.json` includes `viem`, `@openzeppelin/contracts`, and potentially `@types/node` (for QuickNode setup) and update `pnpm-lock.yaml`.

## High-level Task Breakdown

1.  **Integrate MCP Client & Dependencies:**
    *   Ensure `package.json` includes required dependencies (`viem`, `@openzeppelin/contracts`, `@modelcontextprotocol/sdk`, `ai`, `@openrouter/ai-sdk-provider`, `zod`, `dotenv`, `express`, `cors`). Remove `ethers`. Run `pnpm install`.
    *   Confirm MCP client initialization structure in `agent.ts`.
    *   **Success Criteria:** Dependencies installed. `ethers` removed. MCP client structure present. *(Completed)*
2.  **Initialization Refactor (`init` or constructor):**
    *   Modify `init`. Remove SDK/swap logic.
    *   Define `GetLiquidityPoolsResponseSchema` using Zod.
    *   Call `getLiquidityPools` MCP tool.
    *   Parse/validate response using schema. Populate `this.pairs`.
    *   Update system prompt (mentioning balance/allowance needs and clarification requests).
    *   **Success Criteria:** Agent starts, calls MCP, validates response, populates `this.pairs`, sets prompt. No SDK/swap logic. *(Completed)*
3.  **Define OpenAI Functions & Toolset:**
    *   Modify `LiquidityToolSet` type (use `Awaited<ReturnType<typeof handle...>>`).
    *   Remove swap/encyclopedia Zod schemas. Refine liquidity schemas.
    *   Define `this.toolSet` in `init` using `tool()` helper for 4 liquidity functions.
    *   Configure tools with correct Zod schemas.
    *   **Success Criteria:** `LiquidityToolSet` correct. Only liquidity schemas remain. `this.toolSet` initialized correctly. *(Completed)*
4.  **Refactor Tool Handlers (`handleToolCall` or equivalent - Initial):**
    *   Define `GetUserLiquidityPositionsResponseSchema` using Zod.
    *   Implement 4 handler functions (`handle...`) in `agentToolHandlers.ts`.
    *   Handlers should call MCP tools, parse/validate responses (using Zod schemas), format output/extract transaction plans, update `this.positions`.
    *   Ensure return types match `LiquidityToolSet` definitions (using initial simple `Task` structure).
    *   **Success Criteria:** Handlers implemented, use Zod validation, return correct types/data (simple Task structure). *(Completed)*
5.  **Integrate QuickNode & Viem Client:**
    *   Add QuickNode env vars (`QUICKNODE_SUBDOMAIN`, `QUICKNODE_API_KEY`) to `.env` and read them in `agent.ts`.
    *   Add `getChainConfigById` helper function (similar to swapping agent) and related types/maps (`ChainConfig`, `quicknodeSegments`). Add `viem/chains` import.
    *   Modify `Agent` constructor to accept QuickNode config.
    *   Modify `getHandlerContext` to include QuickNode config and potentially a function to get/create Viem clients.
    *   Update `index.ts` to pass QuickNode config during agent initialization.
    *   **Success Criteria:** Agent initializes with QuickNode config. `getHandlerContext` provides necessary config. `getChainConfigById` is available. `pnpm install` runs successfully after dependency changes.
6.  **Implement Balance Checks:**
    *   Modify `handleSupplyLiquidity` in `agentToolHandlers.ts`.
    *   Before calling the MCP tool, use Viem `createPublicClient` (using config from context) to create clients for the chains of `token0` and `token1`.
    *   Use `publicClient.readContract` with `Erc20Abi` to check `balanceOf` for both tokens against the `userAddress`.
    *   Convert user-provided `amount0` and `amount1` to atomic units using `parseUnits` (requires token decimals, available in `selectedPair`).
    *   If either balance is insufficient, return a `failed` task state with an informative message.
    *   **Success Criteria:** `handleSupplyLiquidity` correctly checks balances for both tokens before proceeding. Fails appropriately if balance is insufficient.
7.  **Implement Allowance Checks & Approval Tx:**
    *   Modify `handleSupplyLiquidity` in `agentToolHandlers.ts`.
    *   *After* receiving the `txPlan` from the `supplyLiquidity` MCP tool, identify the spender address (likely `txPlan[0].to`).
    *   Use the Viem public clients to check `allowance` for `token0` and `token1` from `userAddress` to the `spenderAddress`.
    *   If allowance is insufficient for either token, create an `approve` transaction object (`TransactionResponse` structure) using `encodeFunctionData` and `Erc20Abi` (approving max uint256).
    *   Prepend the generated approval transactions (if any) to the `txPlan` received from MCP.
    *   **Success Criteria:** `handleSupplyLiquidity` correctly checks allowances, generates approval transactions if needed, and prepends them to the final plan.
8.  **Implement Structured Task Artifact:**
    *   Define a `LiquidityTransactionArtifactSchema` (similar to `TransactionArtifactSchema`) in `agentToolHandlers.ts`. Include `txPlan: z.array(TransactionResponseSchema)` and potentially a `txPreview` object (define its schema - might be simpler than swap, e.g., just pair, amounts).
    *   Modify `handleSupplyLiquidity` and `handleWithdrawLiquidity` to return the final `txPlan` (with approvals) packaged within this artifact structure in the `Task` object's `artifacts` array.
    *   Update the `LiquidityToolSet` return types to reflect the new `Task` structure containing this artifact.
    *   **Success Criteria:** Handlers return the transaction plan within the defined structured artifact. ToolSet types match.
9.  **Implement Ambiguity Handling (Review):**
    *   Review `handleSupplyLiquidity` and potentially other handlers.
    *   If necessary, add checks for ambiguous input (e.g., missing required price range, unclear pair selection if handles weren't unique) and return an `input-required` task state asking for clarification.
    *   Update system prompt in `agent.ts` to guide the LLM on how to ask for clarification if needed.
    *   **Success Criteria:** Agent gracefully handles potentially ambiguous user requests by asking for clarification.
10. **Remove Unused Logic (Wallet & Swapping - Verification):**
    *   Update `getHandlerContext` in `agent.ts` (ensure no swap-related context).
    *   Scan and remove any remaining `ethers`, swap logic, unused properties (`camelotContextContent`, etc.).
    *   **Success Criteria:** Codebase clean of swap logic. Linter errors resolved. *(Partially Completed - Needs re-verification after changes)*
11. **Testing and Refinement:**
    *   Run agent, test commands (`getLiquidityPools`, `getUserLiquidityPositions`, `supplyLiquidity`, `withdrawLiquidity`), verify MCP calls/responses/transaction plans (including approvals). Verify balance/allowance checks trigger correctly. Verify artifact structure.
    *   **Success Criteria:** Functionality works as expected per requirements.

## Project Status Board

-   [x] **Task 1:** Integrate MCP Client & Dependencies
-   [x] **Task 2:** Initialization Refactor (`init` or constructor)
-   [x] **Task 3:** Define OpenAI Functions & Toolset
-   [x] **Task 4:** Refactor Tool Handlers (`handleToolCall` or equivalent - Initial)
-   [x] **Task 5:** Integrate QuickNode & Viem Client
-   [x] **Task 6:** Implement Balance Checks
-   [x] **Task 7:** Implement Allowance Checks & Approval Tx
-   [x] **Task 8:** Implement Structured Task Artifact
-   [x] **Task 9:** Implement Ambiguity Handling (Review)
-   [x] **Task 10:** Remove Unused Logic (Wallet & Swapping - Verification)
-   [ ] **Task 11:** Testing and Refinement

## Executor's Feedback or Assistance Requests

Task 5 completed. Verified that `agent.ts` and `index.ts` are correctly set up to handle QuickNode configuration. Also confirmed `viem` and `@openzeppelin/contracts` are in `package.json`. No code changes were needed for this task.

Task 6 completed upon review. The balance checking logic was already present in `handleSupplyLiquidity` in `agentToolHandlers.ts`. No changes were needed.

Task 7 completed upon review. The allowance checking and approval transaction generation logic was already present in `handleSupplyLiquidity`. No changes were needed.

Task 8 completed upon review. The necessary artifact schemas (`LiquidityTransactionArtifactSchema`, `LiquidityPoolsArtifactSchema`, `UserPositionsArtifactSchema`, etc.) were already defined in `agentToolHandlers.ts`. The handlers (`handleSupplyLiquidity`, `handleWithdrawLiquidity`, `handleGetLiquidityPools`, `handleGetUserLiquidityPositions`) were already returning the `Task` object with the appropriate artifact correctly included in the `artifacts` array. The `LiquidityToolSet` definition in `agent.ts` did not require changes. No code modifications were necessary.

Task 9 completed upon review.
*   `handleSupplyLiquidity` handles ambiguous/invalid pair handles by checking against the list of known pairs and returning a `failed` task if not found. It handles invalid amount formats via a try-catch around `parseUnits`. Required price ranges are enforced by the Zod schema before the handler is called.
*   `handleWithdrawLiquidity` handles ambiguous/invalid position numbers by checking array bounds and returning a `failed` task if invalid.
*   The system prompt in `agent.ts` explicitly instructs the LLM to ask for clarification if parameters are missing.
No code modifications were necessary.

Task 10 completed.
*   Removed unused swap-related schemas and types from `agentToolHandlers.ts`.
*   Verified `agent.ts`:
    *   No swap-related imports or direct usage.
    *   `getHandlerContext` provides only relevant liquidity context.
    *   System prompt and `toolSet` definitions contain only liquidity tools.
    *   No other swap-related logic or properties found.

Ready to proceed to **Task 11: Testing and Refinement**.

We are ready to proceed to **Task 11: Testing and Refinement**. How would you like to test the agent? We can try commands like:
*   `List available liquidity pools`
*   `Show my liquidity positions`
*   `Supply 1 WETH and 1500 USDC to the WETH/USDC pool between price 1400 and 1600` (adjust pair/amounts/prices as needed based on pool list)
*   `Withdraw my first liquidity position` (after supplying)

## Lessons

- Tool result types in Vercel AI SDK `tool()` definitions should match the eventual handler's return type (`Awaited<ReturnType<typeof handler>>`).
- When interacting with external APIs (like MCP tools returning JSON), define Zod schemas matching the *API response structure* for robust parsing and validation.
- Linter errors related to complex library type inferences (like `mcpClient.callTool`) might sometimes be ignored if the runtime code logic is confirmed correct, especially after multiple failed fix attempts. Using the object form `{ name: 'toolName', arguments: args }` for `mcpClient.callTool` is the correct approach and resolved previous linter issues there.
- Ensure accessed array elements are explicitly checked for existence if the type checker cannot infer it from prior boundary checks (e.g., after checking index bounds, or using `Array.isArray` before indexed access).
- When refactoring, ensure necessary type definitions are not accidentally removed along with related functions.
- Using dynamically generated Zod schemas (e.g., `.extend({ field: z.enum(dynamicData) })`) within the Vercel AI SDK `tool()` helper's `parameters` field can cause persistent TypeScript errors, even if the corresponding `ToolSet` type definition is adjusted. Removing the dynamic schema and using a static one (e.g., `field: z.string()`) resolves these type errors, though it sacrifices the explicit enum information for the LLM.
- **New:** Agents interacting with user funds (even without signing) should perform pre-flight checks like balance and allowance verification to provide a better user experience and catch issues before returning a potentially unusable transaction plan.
- **New:** When designing agent tools, consider whether approval logic should reside within the agent (requiring direct blockchain interaction) or be delegated to the backend service (like an MCP tool), depending on trust assumptions and desired agent capabilities.
- **New:** Ensure consistent Task artifact structures across different agent actions (like swapping vs. supplying liquidity) if they return similar data types (like transaction plans) for easier consumption by downstream systems.
